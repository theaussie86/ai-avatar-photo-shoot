---
phase: 02-core-prompt-generation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/actions/video-prompt-actions.ts
autonomous: true

must_haves:
  truths:
    - "Server action authenticates user before generating prompt"
    - "Image is fetched from Supabase and sent to Gemini for analysis"
    - "Generated prompt is in German and considers all inputs"
    - "Pending record is created before Gemini call, updated after"
    - "Failed generations update status to failed with error message"
  artifacts:
    - path: "app/actions/video-prompt-actions.ts"
      provides: "Server action for video prompt generation"
      exports: ["generateVideoPromptAction"]
      min_lines: 100
  key_links:
    - from: "app/actions/video-prompt-actions.ts"
      to: "lib/video-prompt-schemas.ts"
      via: "imports VideoPromptGenerationSchema"
      pattern: "import.*VideoPromptGenerationSchema.*from.*video-prompt-schemas"
    - from: "app/actions/video-prompt-actions.ts"
      to: "lib/video-prompts.ts"
      via: "imports VIDEO_PROMPT_SYSTEM_PROMPT"
      pattern: "import.*VIDEO_PROMPT_SYSTEM_PROMPT.*from.*video-prompts"
    - from: "app/actions/video-prompt-actions.ts"
      to: "video_prompts table"
      via: "supabase insert/update"
      pattern: "from\\(['\"]video_prompts['\"]\\)"
---

<objective>
Create the server action that generates German video prompts from images using Gemini.

Purpose: Implement the core generation logic that analyzes an image, applies user configuration, and produces a German video prompt optimized for external AI video tools.

Output: A server action file following the established pattern with full async generation flow.
</objective>

<execution_context>
@/Users/cweissteiner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/cweissteiner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-prompt-generation/02-01-SUMMARY.md
@app/actions/image-actions.ts
@lib/supabase/server.ts
@lib/encryption.ts
@lib/video-prompt-schemas.ts
@lib/video-prompts.ts
@types/database.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create video prompt generation server action</name>
  <files>app/actions/video-prompt-actions.ts</files>
  <action>
Create `app/actions/video-prompt-actions.ts` following the pattern in `image-actions.ts`.

**File structure:**

```typescript
"use server"

import { VideoPromptGenerationConfig, VideoPromptGenerationSchema } from "@/lib/video-prompt-schemas";
import { VIDEO_PROMPT_SYSTEM_PROMPT } from "@/lib/video-prompts";
import { decrypt } from "@/lib/encryption";
import { createClient } from "@/lib/supabase/server";
import { GoogleGenAI } from "@google/genai";
import { redirect } from "next/navigation";
```

**Main function: `generateVideoPromptAction`**

1. **Validate input** using VideoPromptGenerationSchema.safeParse()
2. **Authenticate user** via supabase.auth.getUser()
3. **Get API key** from profiles table, decrypt it
4. **Verify image ownership** by fetching image and checking user owns the collection
5. **Create pending record** in video_prompts table:
   - status: 'pending'
   - image_id: from input
   - prompt_text: '' (empty, will be filled)
   - user_instruction: from input
   - camera_style: from input
   - film_effects: from input
   - model_name: 'gemini-2.5-flash'
6. **Fetch image** from Supabase storage (use image.url or storage_path)
7. **Upload to Gemini Files API** (same pattern as image-actions.ts)
8. **Generate prompt** using Gemini with VIDEO_PROMPT_SYSTEM_PROMPT:
   - Include image as fileData part
   - Include user instruction, camera style, film effects in the prompt
9. **Update record** with generated prompt_text and status 'completed'
10. **Handle errors** - update status to 'failed' with error_message

**Return value:**
```typescript
return {
  success: true,
  videoPromptId: record.id,
  promptText: generatedPrompt
};
```

**Error handling:**
- Wrap Gemini call in try/catch
- On failure, update video_prompts record with status='failed', error_message
- Log errors with [VideoPrompt ${imageId}] prefix

**German prompt construction:**
Build the user message to Gemini like:
```typescript
const userMessage = `
Analysiere dieses Bild und erstelle einen Video-Prompt.

${config.userInstruction ? `Anweisungen: ${config.userInstruction}` : ''}

Kamera-Stil: ${cameraStyleLabels[config.cameraStyle]}
${config.filmEffects.length > 0 ? `Film-Effekte: ${config.filmEffects.map(e => filmEffectLabels[e]).join(', ')}` : ''}
`;
```

Define label mappings for German UI values:
```typescript
const cameraStyleLabels: Record<string, string> = {
  cinematic: "Cinematic",
  slow_motion: "Slow Motion",
  zoom_in: "Zoom-In",
  orbit: "Orbit",
  dolly: "Dolly",
  static: "Statisch"
};

const filmEffectLabels: Record<string, string> = {
  dramatic: "Dramatisch",
  soft: "Weich",
  golden_hour: "Golden Hour",
  noir: "Noir",
  dreamy: "Vertraumt"
};
```
  </action>
  <verify>
1. Run `npx tsc --noEmit app/actions/video-prompt-actions.ts` - compiles without errors
2. Verify imports resolve correctly
3. Check function has proper "use server" directive
  </verify>
  <done>
generateVideoPromptAction exists and:
- Validates input with Zod schema
- Authenticates user
- Verifies image ownership
- Creates pending record before Gemini call
- Fetches image and uploads to Gemini
- Generates German video prompt with system instruction
- Updates record to completed with prompt_text
- Updates record to failed with error_message on error
- Returns success with videoPromptId and promptText
  </done>
</task>

<task type="auto">
  <name>Task 2: Add helper function for fetching video prompts</name>
  <files>app/actions/video-prompt-actions.ts</files>
  <action>
Add a helper server action to fetch video prompts for an image.

```typescript
export async function getVideoPromptsForImageAction(imageId: string) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/login");
  }

  // Fetch video prompts (RLS ensures user can only see their own)
  const { data: prompts, error } = await supabase
    .from('video_prompts')
    .select('*')
    .eq('image_id', imageId)
    .order('created_at', { ascending: false });

  if (error) {
    throw new Error("Failed to fetch video prompts: " + error.message);
  }

  return prompts || [];
}
```

This function will be used by the UI in later phases to load existing prompts.
  </action>
  <verify>
Function compiles and returns array of video_prompts for an image.
  </verify>
  <done>
getVideoPromptsForImageAction exported and:
- Authenticates user
- Fetches video_prompts by image_id
- Orders by created_at descending (newest first)
- Returns array of prompts
  </done>
</task>

</tasks>

<verification>
1. File exists at app/actions/video-prompt-actions.ts
2. TypeScript compiles: `npx tsc --noEmit`
3. "use server" directive at top of file
4. Two functions exported: generateVideoPromptAction, getVideoPromptsForImageAction
5. Imports from @/lib/video-prompt-schemas.ts and @/lib/video-prompts.ts resolve
6. Database operations use correct table name 'video_prompts'
</verification>

<success_criteria>
- generateVideoPromptAction creates pending record, calls Gemini, updates to completed/failed
- Action validates input with Zod schema
- Action authenticates user and verifies image ownership
- Generated prompts are in German (via VIDEO_PROMPT_SYSTEM_PROMPT)
- Error handling updates status to 'failed' with error_message
- getVideoPromptsForImageAction fetches prompts for an image
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-prompt-generation/02-02-SUMMARY.md`
</output>
